;; Tests for the dc-eclectic package

(require :cl-ppcre)
(require :dc-ds)
(require :dc-time)
(require :fiveam)

(push (uiop:getcwd) asdf:*central-registry*)
(ql:register-local-projects)
(asdf:load-system :dc-eclectic)

(defpackage :dc-eclectic-tests (:use :cl :fiveam :dc-eclectic :dc-ds :dc-time))

(in-package :dc-eclectic-tests)

(def-suite dc-eclectic-suite :description "Tests for dc-eclectic")

(in-suite dc-eclectic-suite)

(defparameter *x* nil)
(defparameter *msg* "hello")
(defparameter *log-a* nil)
(defparameter *log-b* nil)

(defun top-of-second ()
  (loop with reference-timestamp = (timestamp-string)
    for timestamp = (timestamp-string)
    while (string= timestamp reference-timestamp)
    finally (return timestamp)))

(test toascii-tests
  (is (equal (to-ascii "a") "a")
    "to-ascii with single-ascii-character string")
  (is (equal (to-ascii "abc") "abc")
    "to-ascii with multi-ascii-character string")
  (is (equal (to-ascii "ñ") "?")
    "to-ascii with single-non-ascii-character string")
  (is (equal (to-ascii "ñ¼½¾") "????")
    "to-ascii with multi-non-ascii-character string")
  (is (equal (to-ascii "ñ¼½¾abc") "????abc")
    "to-ascii with multi-non-ascii-character string followed by ascii")
  (is (equal (to-ascii (vector (code-char 129) #\x (code-char 130))
                      :printable-only nil)
               "x")
    "to-ascii chars above high with printable-only nil")
  (is (equal (to-ascii (vector (code-char 29) #\x (code-char 28))
                      :printable-only nil)
               "x")
    "to-ascii chars below min with printable-only nil")
  (is (equal (to-ascii (vector (code-char 1000) #\y (code-char 1001))
                      :printable-only nil)
               "?y?")
    "to-ascii non-ascii chars with printable-only nil"))

(test flatten-tests
  (is (equal (flatten (list 1 2 (list 3 (list 4 (list 5 6) 7) 8) 9))
               (list 1 2 3 4 5 6 7 8 9))
    "flatten nested list of integers")

  (is (equal (flatten (list 1 2 3))
               (list 1 2 3))
    "flatten already-flat list of integers")

  (is (equal (flatten
                      (list "one" "two"
                        (list "three" (list "four" (list "five" "six") "seven") "eight")))
               (list "one" "two" "three" "four" "five" "six" "seven" "eight"))
    "flatten nested list of strings"))

(test join-paths
  ;; join-paths
  (is (equal "" (join-paths nil)))
  (is (equal "a/b/c" (join-paths nil "a" "b" "c")))
  (is (equal "/a/b/c" (join-paths "/" nil "a" "b" "c")))
  (is (equal "a" (join-paths "a")))
  (is (equal "/a" (join-paths "/a")))
  (is (equal "/" (join-paths "/")))
  (is (equal "a/b/c" (join-paths "a" "b" "c")))
  (is (equal "/a/b/c" (join-paths "/a" "b" "c")))
  (is (equal "/a/b/c" (join-paths "/" "a" "b" "c")))
  (is (equal "a/b/c" (join-paths "a" "b" "c" nil)))
  (is (equal "a/b/c" (join-paths "a" "b" "c" "")))
  (is (equal "a/b/c/" (join-paths "a" "b" "c" "/")))
  (is (equal "a/b/c" (join-paths "" "a" "b" "c")))
  (is (equal "a/b/c" (join-paths "a" "" "b" "c")))
  (is (equal "/a/1/b" (join-paths "/" "a" 1 "b")))
  (is (equal "/a/1/b" (join-paths "/a" 1 "b")))
  (is (equal "1/2/3" (join-paths 1 2 3)))
  (is (equal "/a/b/c/" (join-paths "/a" "b" "c/"))))


(test path-only
  (is (equal "" (path-only nil)))
  (is (equal "" (path-only "")))
  (is (equal "/" (path-only "/")))
  (is (equal "/a/b/c/" (path-only "/a/b/c/file.txt")))
  (is (equal "a/b/c/" (path-only "a/b/c/file.txt")))
  (is (equal "" (path-only "file.txt")))
  (is (equal "/" (path-only "/one")))
  (is (equal "/one/" (path-only "/one/")))
  (is (equal "/one/" (path-only "/one/two")))
  (is (equal "/one/two/" (path-only "/one/two/"))))

(test filename-only
  (is (equal (filename-only nil) "")
    "filename-only with nil")
  (is (equal (filename-only "/") "")
    "filename-only with /")
  (is (equal (filename-only "/a/b/c/file.txt") "file.txt")
    "filename-only with /a/b/c/file.txt")
  (is (equal (filename-only "/file.txt") "file.txt")
    "filename-only with /file.txt")
  (is (equal (filename-only "file.txt") "file.txt")
    "filename-only with file.txt")
  (is (equal (filename-only "") "")
    "filename-only with empty string")
  (is (equal (filename-only "file.txt/") "")
    "filename-only with file.txt/"))

(test directory-leaf-only
  (is (equal (leaf-directory-only "/") "/")
    "leaf-directory-only / is /")
  (is (equal (leaf-directory-only "/one") "one")
    "leaf-directory-only /one is one")
  (is (equal (leaf-directory-only "/one/") "one")
    "leaf-directory-only /one/ is one")
  (is (equal (leaf-directory-only "/one/abc.txt") "abc.txt")
    "leaf-directory-only /one/abc.txt is abc.txt")
  (is (equal (leaf-directory-only "/one/two/three/four") "four")
    "leaf-directory-only /one/two/three/four is four"))

(test sorted-hash-tests
  (is (equal (comparable-hash-dump
                      (ds '(:map :one 1 :two 2 :three 3 :four 4 :five 5)))
               '((:five 5) (:four 4) (:one 1) (:three 3) (:two 2)))
    "comparable-hash-dump with keyword keys")
  (is (equal (comparable-hash-dump
                      (ds '(:map :one 1 :two 2 :three 3 :four 4 :five 5))
                      :f-sort #'string>)
               (reverse '((:five 5) (:four 4) (:one 1) (:three 3) (:two 2))))
    "comparable-hash-dump with keyword keys, descending")
  (is (equal (comparable-hash-dump
                      (ds '(:map  5 1   3 2   4 3   1 4   2 5)))
               '((1 4) (2 5) (3 2) (4 3) (5 1)))
    "comparable-hash-dump with integer keys")
  (is (equal (comparable-hash-dump
                      (ds '(:map  5 1   3 2   4 3   1 4   2 5))
                      :f-sort #'<
                      :f-make-sortable #'identity)
               '((1 4) (2 5) (3 2) (4 3) (5 1)))
    "comparable-hash-dump with integer keys, numeric sort")
  (is (equal (comparable-hash-dump
                      (ds '(:map  5 1   3 2   4 3   1 4   2 5))
                      :f-sort #'>
                      :f-make-sortable #'identity)
               (reverse '((1 4) (2 5) (3 2) (4 3) (5 1))))
    "comparable-hash-dump with integer keys, descending numeric sort"))

(test hashify-list-tests
  (is (equal (comparable-hash-dump
                      (hashify-list (list :one :two :three :two :one))
                      :flat t)
               '(:one 2 :three 1 :two 2))
    "hashify-list with keyword keys")
  (is (equal (comparable-hash-dump
                      (hashify-list '(1 2 3 2 1))
                      :flat t
                      :f-sort #'<
                      :f-make-sortable #'identity)
               '(1 2 2 2 3 1))
    "hashify-list with integer keys and numeric sort")
  (is (equal (comparable-hash-dump
                      (hashify-list '("one" "two" "three") :method :index))
               '(("one" 0) ("three" 2) ("two" 1)))
    "hashify-list index method")
  (is (equal (comparable-hash-dump
                      (hashify-list '((:id "a" :first "Alice" :last "Adams" :age 100)
                                       (:id "b" :first "Bob" :last "Baker" :age 101)
                                       (:id "c" :first "Claire" :last "Clark" :age 102))
                        :method :index
                        :plist-key :id))
               '(("a" (:id "a" :first "Alice" :last "Adams" :age 100))
                  ("b" (:id "b" :first "Bob" :last "Baker" :age 101))
                  ("c" (:id "c" :first "Claire" :last "Clark" :age 102))))
    "hashify-list index method plist-key")
  (is (equal (comparable-hash-dump
                      (hashify-list '(:one 1 :two 2 :three 3 :one 11)
                        :method :plist)
                      :flat t)
               '(:one 11 :three 3 :two 2))
    "hashify-list plist method")
  (is (equal (comparable-hash-dump
                      (hashify-list '(:one 1 :two 2 :three 3)
                        :method :plist
                        :f-key (lambda (k) (format nil "~a" k)))
                      :flat t)
               '("ONE" 1 "THREE" 3 "TWO" 2))
    "hashify-list plist method, stringified keys")
  (is (equal (comparable-hash-dump
                      (hashify-list '(:one 1 :two 2 :three 3)
                        :method :plist
                        :f-value (lambda (r c v)
                                   (declare (ignore r c))
                                   (format nil "~a" v)))
                      :flat t)
               '(:one "1" :three "3" :two "2"))
    "hashify-list plist method, strigified values")
  (is (equal (comparable-hash-dump
                      (hashify-list '((:a 11 :b 12 :c 13)
                                       (:a 21 :b 22 :c 23)
                                       (:a 31 :b 32 :c 33)
                                       (:a 41 :b 12 :c 43))
                        :method :count
                        :plist-key :b))
               '(((:a 21 :b 22 :c 23) 1) ((:a 31 :b 32 :c 33) 1) ((:a 41 :b 12 :c 43) 2)))
    "hashify-list list of plists, method count, specifying plist-key"))

(test hash-string-tests
  (is (equal (hash-string "Donnie")
               (format nil "~{~a~}"
                 '("2daf3ad277939e55520a61187c73abc3"
                    "f09b8759ce41469d67ec7fd8f6930c6c"
                    "e943809d1c37312838cef4b40665aa2e"
                    "02803cc0a206c97bb8a476b1d681ca95")))
    "hash-string")
  (is (equal (hash-string "Donnie" :size 32)
               "2daf3ad277939e55520a61187c73abc3")
    "hash-string truncated to 32 characters")
  (is (equal (hash-string "Donnie" :salt "abc" :size 16)
               "f524abffea9ae753")
    "hash-string with salt and truncated to 16 characters")

  (is (equal (hash-hmac-256 "secret" "Donnie")
               "b81c15aafc9935e7138b5c09fc775e66275739370493c06051fea29f5cc6c32a")
    "hash-hmac-256"))

(test distinct-elements-tests
  (is (equal (sort (distinct-elements '(1 2 3 4 3 2 1)) #'<)
               '(1 2 3 4))
    "distinct-elements integers")
  (is (equal (sort (distinct-elements '("abc" "def" "ghi" "jkl" "abc" "def" "ghi" "jkl"))
                      #'string<)
               '("abc" "def" "ghi" "jkl"))
    "distinct-elements with strings")
  (is (equal (sort
                      (mapcar (lambda (x) (format nil "~a" x))
                        (distinct-elements '("one" 1 "two" 2 "three" 3 "two" 2 "one" 1)))
                      #'string<)
               '("1" "2" "3" "one" "three" "two"))
    "distinct-elements with mixed types")
  (is (equal (sort (distinct-elements '((:a 1 :b 2 :c 3)
                                                (:a 4 :b 5 :c 6)
                                                (:a 7 :b 8 :c 9)
                                                (:a 1 :b 2 :c 3)
                                                (:a 4 :b 5 :c 6)
                                                (:a 7 :b 8 :c 9))
                            :key :b)
                      #'< :key (lambda (x) (getf x :b)))
               '((:a 1 :b 2 :c 3)
                  (:a 4 :b 5 :c 6)
                  (:a 7 :b 8 :c 9)))
    "distinct-elements for list with key")
  (is (equal (distinct-elements "donnie") "donie")
    "distinct-elements string"))

(test hash-kv-tests
  (let ((h (ds '(:map :a 1 :b 2 :c 3))))
    (is (equal (sort (hash-values h) #'<)
                 '(1 2 3))
      "hash-values")
    (is (equal (sort (hash-keys h) #'string<)
                 '(:a :b :c))
      "hash-keys")))

(test shuffle-tests
  (let* ((original-list (range 1 100))
          (original-vector (apply #'vector (range 1 100)))
          (shuffled-list (shuffle original-list))
          (shuffled-vector (shuffle original-vector)))
    (is-true (not (equal original-list shuffled-list))
      "shuffled <> original")
    (is (equal (length original-list) (length shuffled-list))
      "original and shuffled same length")
    (is (equal (comparable-hash-dump (hashify-list original-list))
                 (comparable-hash-dump (hashify-list shuffled-list)))
      "original and shuffled same elements, same count per element")
    (is (equal (comparable-hash-dump
                        (hashify-list (map 'list 'identity original-vector)))
                 (comparable-hash-dump
                   (hashify-list (map 'list 'identity shuffled-vector))))
      "original and shuffled vectors same elements, same count per element")))

(test range-tests
  (is (equal (range 1 3) '(1 2 3))
    "range 1-3")
  (is (equal (range 1 5 :step 2) '(1 3 5))
    "range 1-5 by 2")
  (is (equal (range 1 5 :filter #'evenp) '(2 4))
    "range 1-5 even")
  (is (equal (loop for a from 1 to 100
                      for range = (range 1 10 :shuffle t)
                      collect (car range) into heads
                      finally (return
                                (loop with ref = (car heads)
                                  for head in heads thereis (not (= head ref)))))
               t)
    "range shuffled"))

(test permutation-tests
  (is (equal (all-permutations '(1 2 3))
               '((1 2 3)
                  (1 3 2)
                  (2 1 3)
                  (2 3 1)
                  (3 1 2)
                  (3 2 1)))
    "all-permutations distinct integers")
  (is (equal (all-permutations-of-string "one")
               '("one" "oen" "noe" "neo" "eon" "eno"))
    "all-permutations-of-string")
  (is (equal (existing-permutations-of-string
                      "one" (ds '(:map "one" t "neo" t "eon" t)))
               '("one" "neo" "eon"))
    "existing-permutations-of-string")
  (is (equal (n-gram-strings "ab" 3)
               '("aaa" "aab" "aba" "abb" "baa" "bab" "bba" "bbb"))
    "n-gram-strings")
  (is (equal (existing-n-gram-strings
                      "abc" 3 (ds '(:map "aba" t "bbc" t "cab" t "hello" t "one" t "two" t)))
               '("aba" "bbc" "cab"))
    "existing-n-gram-strings"))

(test verify-string-tests
  (is (equal (verify-string "Donnie" "Donnie") t)
    "verify-string 1")
  (is (equal (verify-string "Donnie" "^D.+e$") t)
    "verify-string 2")
  (is (equal (verify-string "Donnie" "^Do") nil)
    "verify-string 3")
  (is (equal (verify-string "Donnie" "e$") nil)
    "verify-string 4")
  (is (equal (verify-string "Donnie" "^d.+") nil)
    "verify-string 5")
  (is (equal (verify-string "Donnie" "^d.+" :ignore-case t) t)
    "verify-string 6")
  (is (equal (verify-string "Donnie" "^.+$") t)
    "verify-string 7"))

(test plistp-tests
  (is-true (plistp '(:one 1 :two 2 :three 3)))
  (is-true (not (plistp '(:one 1 :two :three 3)))))

(test file-tests
  (let* ((root "/tmp/dc-eclectic-tests/")
          (file-name-1 (format nil "~afile-1.txt" root))
          (file-name-2 (format nil "~afile-2.txt" root))
          (dir-name-1 (format nil "~adir-1/" root))
          (dir-name-2 (format nil "~adir-2/" root)))
    (when (directory-exists-p root)
      (uiop:delete-directory-tree (pathname root) :validate t))
    (ensure-directories-exist dir-name-1)
    (with-open-file (out file-name-1 :direction :output :if-exists :supersede)
      (write-line "Hello World!" out))
    (is-true (file-exists-p file-name-1)
      (format nil "file exists: ~a" file-name-1))
    (is-true (not (file-exists-p file-name-2))
      (format nil "file does not exists: ~a" file-name-2))
    (is-true (not (file-exists-p dir-name-1))
      (format nil "file does not exist (it's a directory): ~a" dir-name-1))
    (is-true (not (file-exists-p dir-name-2))
      (format nil "file does not exist: ~a" dir-name-2))
    (is-true (directory-exists-p dir-name-1)
      (format nil "directory exists: ~a" dir-name-1))
    (is-true (not (directory-exists-p dir-name-2))
      (format nil "directory does not exist: ~a" dir-name-2))
    (is-true (not (directory-exists-p file-name-1))
      (format nil "file exists, but it's not a directory: ~a" file-name-1))
    (is-true (not (directory-exists-p file-name-2))
      (format nil "file does not exist as is not a directory: ~a" file-name-2))
    (uiop:delete-directory-tree (pathname root) :validate t)))

(test index-of-max-tests
  (is-true (null (index-of-max nil))
    "index-of-max nil")
  (is-true (null (index-of-max (vector)))
    "index-of-max empty vector")
  (is-true (zerop (index-of-max '(0)))
    "index-of-max single element")
  (is-true (zerop (index-of-max (vector 0)))
    "index-of-max single element vector")
  (is (equal (index-of-max '(0 1)) 1)
    "index-of-max two elements")
  (is (equal (index-of-max (vector 0 1)) 1)
    "index-of-max two elements vector")
  (is-true (zerop (index-of-max '(1 0)))
    "index-of-max two elements reverse")
  (is-true (zerop (index-of-max (vector 1 0)))
    "index-of-max two elements reverse vector")
  (is (equal (index-of-max '(-1 1 0)) 1)
    "index-of-max three elements")
  (is (equal (index-of-max (vector -1 1 0)) 1)
    "index-of-max three elements vector")
  (is-true (zerop (index-of-max '(-1 -2 -3 -9)))
    "index-of-max all negative")
  (is-true (zerop (index-of-max (vector -1 -2 -3 -9)))
    "index-of-max all negative vector")
  (is (equal (index-of-max '(-1 -2 -3 0)) 3)
    "index-of-max one zero")
  (is (equal (index-of-max (vector -1 -2 -3 0)) 3)
    "index-of-max one zero vector")
  (is-true (zerop (index-of-max '(9 -2 -3 -1)))
    "index-of-max all negative reverse")
  (is-true (zerop (index-of-max (vector 9 -2 -3 -1)))
    "index-of-max all negative reverse vector"))

(test choose-one-tests
  (let* ((list '(1 2 3 4 5))
          (rstate (make-random-state (reference-random-state)))
          (a (choose-one list rstate)))
    (is-true (loop for a from 1 to 10
                      for choice = (choose-one list)
                      always (and (= (truncate choice) choice)
                               (>= choice 1)
                               (<= choice 5)))
      "choose-one always returns an element of seq")
    (is (equal 1 a)
      "first call to choose-one with rstate returns same element")
    (is-true (null (choose-one nil))
      "choose-one of nil is nil")
    (is-true (loop for a from 1 to 10
                      always (= (choose-one (list a)) a))
      "choose-one of a single-value list is always the single value")))

(test choose-some-tests
  (is-true (loop with list = '(1 2 3 4 5)
                    for a from 1 to 20
                    for choice = (choose-some list 1)
                    always (and (= (length choice) 1)
                             (>= (car choice) 1)
                             (<= (car choice) 5)))
    "choose-some seq 1 always returns a single value from the sequence")
  (is (equal (choose-some '(1 2 3 4 5) 5) '(1 2 3 4 5))
    "choose-some seq (length seq) always returns a copy of the sequence.")
  (let ((some (sort (choose-some '(1 2 3 4 5) 4) #'<)))
    (is (equal (sort (distinct-elements some) #'<) some)
      "choose-some returns elements from SEQ that have distinct indexes")
    (is-true (loop for a in some always (and (>= a 1) (<= a 5)))
      "choose-some returns elements from SEQ")
    (is (equal (length some) 4)
      "choose-some returns the correct number of elements"))
  (is-true (null (choose-some '(1 2 3 4 5) 0))
    "choose-some returns nil if N = 0")
  (is-true (null (choose-some '(1 2 3 4 5) -1))
    "choose-some returns nil if N < 0")
  (is-true (null (choose-some nil 2))
    "choose-some returns nil if SEQ is empty")
  (let ((some (sort (choose-some (vector 1 2 3) 2) #'<)))
    (is-true (or (equalp some (vector 1 2))
                      (equalp some (vector 2 3))
                      (equalp some (vector 1 3)))
      "choose-some works with vectors")))

(test spew-and-slurp-tests
  (let* ((string "hello world")
          (filename "/tmp/hello.txt"))
    (spew string filename)
    (is-true (uiop:file-exists-p filename)
      "spew created file")
    (is (equal (slurp filename) string)
      "slurp returns spewed string")
    (delete-file filename))
  (let* ((original (list 1 "one" :one t nil '(2 3 4)))
          (frozen (freeze original))
          (thawed (thaw frozen)))
    (is (equal (length original) (length thawed))
      "Thawed list has correct length")
    (is (equal original thawed)
      "Thawed list is the same as original list"))
  (let* ((filename "/tmp/hello.txt")
          (original (list "hello" :world)))
    (spew (freeze original) filename)
    (let ((thawed (thaw (slurp filename))))
      (is (equal thawed original))
      (is (equal (car thawed) "hello")
        "First element of thawed list is \"hello\"")
      (is (equal (second thawed) :world)
        "Second element of thawed list is :world"))))

(test split-n-trim-tests
  (let* ((s1 "one two three")
          (s2 "  one     two three   ")
          (s3 "123one456 789two10 1112three14   ")
          (p1-actual (split-n-trim s1))
          (p2-actual (split-n-trim s2))
          (p3-actual (split-n-trim s3 :fat "\\d+"))
          (expected (list "one" "two" "three")))
    (is (equal p1-actual expected)
      "split-n-trim words separated by single space")
    (is (equal p2-actual expected)
      "split-n-trim words separated by multiple spaces")
    (is (equal p3-actual expected)
      "split-n-trim words separated by spaces, trimming digits from each word")))

(test trim-tests
  (is (equal "hello" (trim "      hello       "))
    "trim spaces around a string")
  (is (equal "hello" (trim "01234hello67890" "\\d+"))
    "trim digits around a string")
  (is (equal "hello" (trim "	 	hello 	"))
    "trim whitespace"))

(test setenv-getenv-tests
  (is (equal (getenv "BOGUS_ENVIRONMENT_VARIABLE" :default "x") "x")
    "Read non-set environment variable with default")
  (is (equal (getenv "BOGUS_ENVIRONMENT_VARIABLE" :default 1) 1)
    "Read non-set environment variable with an integer default")
  (is (equal (setenv "BOGUS_ENVIRONMENT_VARIABLE" 1) "1")
    "Set environment variable")
  (is (equal (getenv "BOGUS_ENVIRONMENT_VARIABLE") "1")
    "Read set environment variable")
  (is (equal (getenv "BOGUS_ENVIRONMENT_VARIABLE" :type :integer) 1)
    "Read set environment variable as an integer")
  (is (equal (setenv "BOOLEAN_ENVIRONMENT_VARIABLE" t) "true")
    "Set boolean environment variable to true")
  (is (equal (getenv "BOOLEAN_ENVIRONMENT_VARIABLE" :type :boolean) t)
    "Read boolean environment variable (true)")
  (is (equal (setenv "BOOLEAN_ENVIRONMENT_VARIABLE" nil) "false")
    "Set boolean environment variable to false")
  (is (equal (getenv "BOOLEAN_ENVIRONMENT_VARIABLE" :type :boolean) nil)
    "Read boolean environment variable (false)")
  (is (equal (getenv "BOOLEAN_ENVIRONMENT_VARIABLE_X"
                      :type :boolean :default nil)
               nil)
    "Read boolean environment variable with default (false)")
  (is (equal (getenv "BOOLEAN_ENVIRONMENT_VARIABLE_X"
                      :type :boolean :default t)
               t)
    "Read boolean environment variable with default (true)"))

(test random-tests
  (let ((rstate1 (reference-random-state))
         (rstate2 (reference-random-state)))
    (is-true (not (= (random 1000000) (random 1000000))))
    (is (equal (random 1000000 rstate1) (random 1000000 rstate2))))

  ;; Other random things
  (is (equal (length (format nil "~a" (random-number 1))) 1)
    "random-number produces a 1-digit number")
  (is (equal (length (format nil "~a" (random-number))) 4)
    "random-number produces a 4-digit number")
  (is (equal (length (format nil "~a" (random-number 10))) 10)
    "random-number produces a 10-digit number")
  (is-true (cl-ppcre:scan "^[a-f0-9]{10}$" (random-hex-number 10))
    "random-hex-number produces a good hex number")
  (is-true (cl-ppcre:scan "^[a-c]{10}$" (random-string 10 "abc"))
    "random-string works")
  (is-true (cl-ppcre:scan "^[a-z0-9]{10}" (random-string 10 (ascii-alpha-num-lower)))
    "random-string with ascii-alpha-num-lower")
  (is-true (cl-ppcre:scan "^[A-Z0-9]{10}" (random-string 10 (ascii-alpha-num-upper)))
    "random-string with ascii-alpha-num-upper")
  (is-true (cl-ppcre:scan "^[0-9]{10}" (random-string 10 (ascii-numeric)))
    "random-string with ascii-numeric")
  (is-true (cl-ppcre:scan "^[a-f0-9]{8}(-[a-f0-9]{4}){3}-[a-f0-9]{12}$" (uuid))
    "uuid works"))

(test copy-file-tests
  (let ((src (format nil "/tmp/~a.txt" (random-string 20 (ascii-alpha-num))))
         (dest (format nil "/tmp/~a.txt" (random-string 20 (ascii-alpha-num)))))
    (spew "Message 1" src)
    (copy-file src dest)
    (is (equal (slurp src) (slurp dest))
      "file copied")
    (spew "Message 2" src)
    (is-true (not (equal (slurp src) (slurp dest)))
      "first file changed")
    (copy-file src dest)
    (is (equal (slurp src) (slurp dest))
      "destination file superseded")
    (spew "Message 3" src)
    (copy-file src dest :if-exists :append)
    (is (equal (slurp dest) "Message 2Message 3")
      "destination file appended")
    (signals error (copy-file src dest :if-exists :error)
      "destination file exists and :if-exists is :error")
    (delete-file src)
    (delete-file dest)))

(test base64-tests
  ;; base64-encoding
  (let ((s "Hello, beautiful World!"))
    (is (equal s (base64-decode (base64-encode s)))
      "Roundtrip base64-encoding works"))
  (is (equal "x" (base64-decode (base64-encode "x")))
    "Rountrip for 1 char")
  (is (equal (base64-encode "") "")
    "base64-encode empty string -> empty string")
  (is (equal (base64-decode "") "")
    "base64-decode empty string -> empty string")
  (is (equal (base64-encode nil) "")
    "base64-encode nil -> empty string")
  (is (equal (base64-decode nil) "")
    "base64-decode nil -> empty string"))

(test encoding-tests
  (let ((s "Hello, beautiful World!┼"))
    (is (equal s (safe-decode (safe-encode s)))
      "Roundtrip safe-encoding works"))
  (is (equal "x" (safe-decode (safe-encode "x")))
    "Rountrip for 1 char")
  (is (equal (safe-encode "") "")
    "safe-encode empty string -> empty string")
  (is (equal (safe-decode "") "")
    "safe-decode empty string -> empty string")
  (is (equal (safe-encode nil) "")
    "safe-encode nil -> empty string")
  (is (equal (safe-decode nil) "")
    "safe-decode nil -> empty string"))

(test shell-command-to-string-tests
  (is (shell-command-to-string "echo 'hello'") "hello"))

(test shell-command-background-tests
  (let ((info (shell-command-background "echo hello")))
    (is (equal (getf info :status) :running) "process 1 info contains :status")
    (sleep 0.1)
    (is-false (shell-command-running-p info) "process 1 is no longer running")
    (let ((info (shell-command-wait info)))
      (is (equal (getf info :output) (format nil "hello~%"))
            "process 1 output is hello")
      (is (equal (getf info :error-output) "") "process 1 has no error output")
      (is (equal (getf info :status) :completed)
        "process 1 status is completed")
      (is (equal (getf info :exit-code) 0) "process 1 exit code is 0")))
  (let* ((info1 (shell-command-background "sleep 1 && echo awake"))
          (info2 (shell-command-wait info1)))
    (is (equal (getf info2 :status) :completed) "process 2 status is completed")
    (is (equal (getf info2 :exit-code) 0) "process 2 exit code is 0")
    (is (equal (getf info2 :output) (format nil "awake~%"))
      "process 2 output is awake"))
  (let* ((info1 (shell-command-background "sleep 10 && echo awake"))
          (info2 (shell-command-wait info1 1)))
    (is (equal (getf info2 :status) :terminated)
      "process 3 status is terminated")
    (is (equal (getf info2 :exit-code) 15)
      "process 3 expected exit-code 15, got ~a" (getf info2 :exit-code))
    (is (equal (getf info2 :output) nil)
      "process 3 expected output \"\", got ~a" (getf info2 :output))))

(test safe-sort
  (let* ((numeric-1 (range 1 10 :shuffle t))
          (numeric-2 (copy-seq numeric-1))
          (numeric-3 (safe-sort numeric-1))
          (alpha-1 (loop for a from 1 to 10
                     collect (random-string 4 (ascii-alpha))))
          (alpha-2 (copy-seq alpha-1))
          (alpha-3 (safe-sort alpha-1))
          (weird-1 '((1 2 "hello") ("beautiful" 3 4 5) ("world" 6))))
    (is (equal numeric-1 numeric-2)
      "expected (~{~a~^, ~}); got (~{~a~^, ~})")
    (is-true (loop for a in numeric-3 for b in (rest numeric-3)
               always (< a b))
      "expected (~{~a~^, ~}) to be sorted")
    (is (equal alpha-1 alpha-2)
      "expected (~{~a~^, ~}); got (~{~a~^, ~})")
    (is-true (loop for s1 in alpha-3 for s2 in (rest alpha-3)
               always (string< s1 s2))
      "expected (~{~a~^, ~}) to be sorted")
    (signals simple-error (safe-sort weird-1))))

(test has
  ;; Numbers
  (is-true (has '(1 2 3) 1))
  (is-true (has '(1 2 3) 2))
  (is-true (has '(1 2 3) 3))
  (is-true (has '(1 2 3) '(1)))
  (is-true (has '(1 2 3) '(2)))
  (is-true (has '(1 2 3) '(3)))
  (is-true (has '(1 2 3) '(1 2)))
  (is-true (has '(1 2 3) '(1 3)))
  (is-true (has '(1 2 3) '(1 2 3)))
  (is-true (has '(1 2 3) '(1 3)))
  (is-true (has '(1 2 3) nil))
  (is-true (has nil nil))
  (is-true (has '(1) 1))
  (is-true (has '(1) '(1)))
  (is-false (has nil '(1 2 3)))
  (is-false (has '(1 2 3) 4))
  (is-false (has '(1 2 3) '(4)))
  (is-false (has '(1 2 3) '(3 4)))
  (is-false (has '(1 2 3) 0))
  (is-false (has '(1 2 3) '(0)))
  ;; Strings
  (is-true (has '("one" "two" "three") "one"))
  (is-true (has '("one" "two" "three") "two"))
  (is-true (has '("one" "two" "three") "three"))
  (is-true (has '("one" "two" "three") '("one")))
  (is-true (has '("one" "two" "three") '("two")))
  (is-true (has '("one" "two" "three") '("three")))
  (is-true (has '("one" "two" "three") '("one" "two")))
  (is-true (has '("one" "two" "three") '("one" "three")))
  (is-true (has '("one" "two" "three") '("one" "two")))
  (is-true (has '("one" "two" "three") '("one" "three")))
  (is-true (has '("one" "two" "three") nil))
  (is-true (has nil nil))
  (is-true (has '("one") "one"))
  (is-true (has '("one") '("one")))
  (is-true (has '("one" "two" "three") '()))
  (is-false (has nil '("one" "two" "three")))
  (is-false (has '("one" "two" "three") "four"))
  (is-false (has '("one" "two" "three") '("three" "four")))
  (is-false (has '("one" "two" "three") "zero")))

(test has-some
  (is-true (has-some '(1 2 3) '(1)))
  (is-true (has-some '(1 2 3) '(2)))
  (is-true (has-some '(1 2 3) '(3)))
  (is-true (has-some '(1 2 3) '(1)))
  (is-true (has-some '(1 2 3) '(1 4)))
  (is-true (has-some '(1 2 3) '(1 2 3 4)))
  (is-true (has-some '(1 2 3) '(3 4 5 6)))
  (is-true (has-some '(1 2 3) nil))
  (is-true (has-some nil nil))
  (is-true (has-some '(1) '(1)))
  (is-false (has-some nil '(1 2 3)))
  (is-false (has-some '(1 2 3) '(4)))
  (is-false (has-some '(1 2 3) '(0 4)))
  (is-false (has-some '(1 2 3) '(0)))
  (is-false (has-some '(1 2 3) '(4 5 6)))
  (is-false (has-some nil '(1)))
  ; Strings
  (is-true (has-some '("one" "two" "three") '("one")))
  (is-true (has-some '("one" "two" "three") '("one" "three")))
  (is-true (has-some '("one" "two" "three") '("one" "four")))
  (is-true (has-some '("one" "two" "three") '("three" "four")))
  (is-true (has-some '("one" "two" "three") '("three" "four" "five"))))

(test exclude
  (is (equal '(2 3) (exclude '(1 2 3) 1)))
  (is (equal '(1 3) (exclude '(1 2 3) 2)))
  (is (equal '(1 2) (exclude '(1 2) 5)))
  (is (equal nil (exclude '(1 2 3) '(1 2 3))))
  (is (equal '(1 2) (exclude '(1 2) nil)))
  (is (equal '("one" "three") (exclude '("one" "two" "three") "two"))))

(test exclude-regex
  (is (equal '("one" "three") (exclude-regex '("one" "two" "three") "w"))))

(test deep-copy
  (let* ((original '(1 2 "three" (4 nil 5 (6 "seven"))))
          (copy (deep-copy original)))
    (is (equal '(1 2 "three" (4 nil 5 (6 "seven"))) original))
    (is (equal '(1 2 "three" (4 nil 5 (6 "seven"))) copy))
    (setf (car copy) "one")
    (is (equal '(1 2 "three" (4 nil 5 (6 "seven"))) original))
    (is (equal '("one" 2 "three" (4 nil 5 (6 "seven"))) copy))
    (setf (third copy) "Three")
    (is (equal '(1 2 "three" (4 nil 5 (6 "seven"))) original))
    (is (equal '("one" 2 "Three" (4 nil 5 (6 "seven"))) copy))
    (setf (second (fourth (fourth copy))) 7)
    (is (equal '(1 2 "three" (4 nil 5 (6 "seven"))) original))
    (is (equal '("one" 2 "Three" (4 nil 5 (6 7))) copy)))
  (let* ((original '(:one :two (:three (:four :five))))
          (copy (deep-copy original)))
    (is (equal '(:one :two (:three (:four :five))) original))
    (is (equal '(:one :two (:three (:four :five))) copy))
    (setf (second (second (third copy))) :fiver)
    (is (equal '(:one :two (:three (:four :five))) original))
    (is (equal '(:one :two (:three (:four :fiver))) copy))
    (setf (cdr copy) nil)
    (is (equal '(:one :two (:three (:four :five))) original))
    (is (equal '(:one) copy)))
  (let* ((original '(:one (vector 2 3 "four")))
          (copy (deep-copy original)))
    (is (equal '(:one (vector 2 3 "four")) original))
    (is (equal '(:one (vector 2 3 "four")) copy))
    (setf (elt (second copy) 3) "Four")
    (is (equal '(:one (vector 2 3 "four")) original))
    (is (equal '(:one (vector 2 3 "Four")) copy))))

(test singular
  (is (equal "widget" (singular "widgets")))
  (is (equal "workman" (singular "workmen")))
  (is (equal "lady" (singular "ladies")))
  (is (equal "child" (singular "children")))
  (is (equal "tooth" (singular "teeth")))
  (is (equal "my_child" (singular "my_children")))
  (is (equal "directory" (singular "directories")))
  (is (equal "file" (singular "files")))
  (is (equal "datum" (singular "data"))))

(test plural
  (is (equal "widgets" (plural "widget")))
  (is (equal "workmen" (plural "workman")))
  (is (equal "ladies" (plural "lady")))
  (is (equal "children" (plural "child")))
  (is (equal "teeth" (plural "tooth")))
  (is (equal "my_children" (plural "my_child")))
  (is (equal "directories" (plural "directory")))
  (is (equal "files" (plural "file")))
  (is (equal "data" (plural "datum"))))

(test tree-get
  (let ((tree '(:files
                 (:enable t
                   :fields ((:name "size" :type :integer)
                             (:name "type" :type :text)
                             (:name "description" :type :text
                               :default "No description")
                             (:name "hash" :type :text :unique t)
                             (:name "xgroup" :type :integer :required t)))
                 :directories (:enable t :fields nil))))
    (is-true (tree-get tree :files :enable))
    (is-true (tree-get tree :directories :enable))
    (is (equal 5 (length (tree-get tree :files :fields))))
    (is (equal (tree-get tree :files :fields 0)
          '(:name "size" :type :integer)))
    (is (equal (tree-get tree :files :fields 1)
          '(:name "type" :type :text)))
    (is (equal (tree-get tree :files :fields 2 :default)
               "No description"))
    (is-true (tree-get tree :files :fields 3 :unique))
    (is-true (tree-get tree :files :fields 4 :required))
    (is (equal '(:integer :text :text :text :integer)
          (mapcar (lambda (subtree) (tree-get subtree :type))
            (tree-get tree :files :fields))))))

(test tree-put
  (let ((tree '(:files
                 (:enable t
                   :fields ((:name "size" :type :integer)
                             (:name "type" :type :text)
                             (:name "description" :type :text
                               :default "No description")
                             (:name "hash" :type :text :unique t)
                             (:name "xgroup" :type :integer :required t)))
                 :directories (:enable t :fields nil))))
    (let ((copy (deep-copy tree)))
      (is (equal tree copy))
      (tree-put "New description" copy :files :fields 2 :default)
      (is (equal "New description" (tree-get copy :files :fields 2 :default)))
      (is (equal "No description" (tree-get tree :files :fields 2 :default))))
    (let ((copy (deep-copy tree)))
      (is-true (tree-get copy :files :fields 3 :unique))
      (tree-put nil copy :files :fields 3 :unique)
      (is-false (tree-get copy :files :fields 3 :unique)))
    (let ((copy (deep-copy tree)))
      (is (equal :text (tree-get copy :files :fields 1 :type)))
      (tree-put :integer copy :files :fields 1 :type)
      (is (equal :integer (tree-get copy :files :fields 1 :type))))))

(test path-parent
  (is (equal "/" (path-parent "/one")))
  (is (equal "/" (path-parent "/one/")))
  (is (equal "/" (path-parent "/one.txt")))
  (is-false (path-parent "one"))
  (is-false (path-parent ""))
  (is-false (path-parent "/"))
  (is (equal "/one/" (path-parent "/one/two/")))
  (is (equal "/one/" (path-parent "/one/two")))
  (is (equal "/one/" (path-parent "/one/two.txt")))
  (is (equal "/one/two/" (path-parent "/one/two/three")))
  (is (equal "/one/two/" (path-parent "/one/two/three.txt"))))

(test starts-with
  (is-true (starts-with "hello world" "hello"))
  (is-true (starts-with "hello" "hello"))
  (is-true (starts-with "hello" "h"))
  (is-true (starts-with "h" "h"))
  (is-false (starts-with "hello world" "world"))
  (is-false (starts-with "hello" "world"))
  (is-false (starts-with "hello" "hello world"))
  (is-true (starts-with "hello" ""))
  (is-true (starts-with "" ""))
  (is-false (starts-with "" "x")))

(test ends-with
  (is-true (ends-with "hello world" "world"))
  (is-true (ends-with "hello world" "hello world"))
  (is-true (ends-with "hello world" "d"))
  (is-true (ends-with "hello world" ""))
  (is-true (ends-with "h" "h"))
  (is-true (ends-with "" ""))
  (is-false (ends-with "hello world" "hello"))
  (is-false (ends-with "hello" "hello world"))
  (is-false (ends-with "" "x"))
  (is-false (ends-with "hello" "hellohello")))

;;; Run tests
(unless (run-all-tests)
  (sb-ext:quit :unix-status 1))
